[{"categories":["tools"],"content":"IPTV电信电视频道列表的抓取教程","date":"2022-11-13  21:33:30","objectID":"/iptv/","tags":["iptv","openwrt","wireshark","tcpdump"],"title":"IPTV电信电视频道列表的抓取教程","uri":"/iptv/"},{"categories":["tools"],"content":"前景提要 IPTV 频道的抓包教程其实有很多，但是在看过这个多的教程之后还是踩了一个很无语的坑。真实诠释了：听过了这么多道理，还是过不好这一生。 因为引用的教程都有很详细的配图，我的教程就不配图了。偷下懒，见谅一下。 ","date":"2022-11-13  21:33:30","objectID":"/iptv/:0:1","tags":["iptv","openwrt","wireshark","tcpdump"],"title":"IPTV电信电视频道列表的抓取教程","uri":"/iptv/"},{"categories":["tools"],"content":"相关教程 https://www.cnblogs.com/leokale-zz/p/13272694.html https://www.right.com.cn/forum/thread-308436-1-1.html https://www.right.com.cn/forum/thread-4389926-1-2.html https://mozz.ie/posts/extracting-iptv-live-streams https://wp.gxnas.com/1189.html https://guihet.com/iptvstudy-diyzbsq.html ","date":"2022-11-13  21:33:30","objectID":"/iptv/:0:2","tags":["iptv","openwrt","wireshark","tcpdump"],"title":"IPTV电信电视频道列表的抓取教程","uri":"/iptv/"},{"categories":["tools"],"content":"刷机相关工具 红米AC2100 路由器（刷OPENWRT系统），可以在 PC 上通过 SSH 工具连接路由器。 电信IPTV盒子+遥控器（没有可以使用有红外功能的手机替代） 显示器一台连接盒子播放电视 pc 一台 （win11 系统） 电信IPTV专线一条 ","date":"2022-11-13  21:33:30","objectID":"/iptv/:0:3","tags":["iptv","openwrt","wireshark","tcpdump"],"title":"IPTV电信电视频道列表的抓取教程","uri":"/iptv/"},{"categories":["tools"],"content":"抓包流程 专线连接盒子进入设置界面，获取IPTV的账号和密码。这一步很简单，对我来说却挺难得，因为我没有遥控器。因为电视盒子是公司的，上一位同事离职交接的时候没有交接遥控器。然后我的手机有没有红外，最后是借用其他同事的手机安装了万能遥控才进入设置界面。 拿到账号和密码以后，我们切换盒子的联网模式到DHCP自动获取模式。这一步非常重要，我就是这一步没有设置导致后面一直在走弯路。因为如果是在盒子内拨号的话，那么不管你是使用路由器，还是使用抓包神器，甚至是交换机的端口镜像功能都是没有办法抓到频道的。 登录路由器后台，设置lan1（接入IPTV专线）,lan2（用网线接入到iptv盒子）桥接(名称为 iptv，后面会用到)，lan3 连接 pc (用于SSH登录)；并在次桥接网卡上PPPOE拨号iptv(使用前面获取到的账号密码)。打开盒子查看电视频道，如果现在能够正常观看电视，那么你离抓取到电视频道信息只差最后一步。 在 PC 上通过 SSH 登录路由器，在路由器上安装 tcpdump 工具，其实就是 wireshark 一样的工具，只是是命令行版本。 先关闭电视盒子，然后执行 tcpdump -i iptv -w /tmp/iptv.cap ,然后打开电视盒子，选择直播列表随意播放一个频道。发现命令行界面出现数据之后，ctrl+c 取消 tcpdump 命令。 现在 iptv.cap 文件到 PC 上,使用 wireshark 打开，并导出 HTTP 对象。找到 getchannellistHWCTC.jsp 选择将它保存成文件。 打开 getchannellistHWCTC.jsp 文件，文件头部添加代码如下（并注释 goServicesEntry 方法）： \u003cscript\u003e const goServicesEntry = function () { }; var Authentication = {}; var m3u8Channels = \"\"; Authentication['CTCSetConfig'] = function () { const regex = /,?(.+?)=\"(.*?)\"/gm; if (arguments[0] == 'Channel') { var info = {}; while ((m = regex.exec(arguments[1])) !== null) { if (m.index === regex.lastIndex) { regex.lastIndex++; } if (m[1] == \"ChannelName\") { m3u8Channels += \"#EXTINF:-1 tvg-name=\\\"\" + m[2] + \"\\\",\" + m[2] + \"\\n\" } if (m[1] == \"ChannelURL\") { const channelURL = m[2].split(\"|\"); if (channelURL.length == 2) { m3u8Channels += channelURL[1] + \"\\n\" } } } } } setTimeout(function () { var a = window.document.createElement('a'); a.href = window.URL.createObjectURL(new Blob([m3u8Channels], { type: 'application/x-mpegURL' })); a.download = 'IPTV.m3u8'; document.body.appendChild(a); a.click(); document.body.removeChild(a); }, 1000); \u003c/script\u003e 修改 getchannellistHWCTC.jsp 文件名为 getchannellistHWCTC.html 并在浏览器打开，就可以下载得到后缀 .m3u8 的源文件了。 ","date":"2022-11-13  21:33:30","objectID":"/iptv/:0:4","tags":["iptv","openwrt","wireshark","tcpdump"],"title":"IPTV电信电视频道列表的抓取教程","uri":"/iptv/"},{"categories":["tools"],"content":"路由刷机教程需要根据需求自行搜索，一下附上红米AC2100的刷机教程 https://supes.top/%E7%BA%A2%E7%B1%B3-%E5%B0%8F%E7%B1%B3-ac2100-%E5%88%B7breed%E5%92%8Copenwrt%E6%95%99%E7%A8%8B/ https://www.right.com.cn/forum/thread-4023907-1-1.html https://www.right.com.cn/forum/forum.php?mod=viewthread\u0026tid=8234820\u0026extra=page%3D1%26filter%3Dtypeid%26typeid%3D43\u0026page=1 ","date":"2022-11-13  21:33:30","objectID":"/iptv/:0:5","tags":["iptv","openwrt","wireshark","tcpdump"],"title":"IPTV电信电视频道列表的抓取教程","uri":"/iptv/"},{"categories":["Golang"],"content":"Golang 程序中获取执行目录的几种方式","date":"2021-07-11  14:23:13","objectID":"/dir/","tags":["Golang","dir"],"title":"Golang 程序中获取执行目录的几种方式","uri":"/dir/"},{"categories":["Golang"],"content":"前言 go 语言开发中经常需要获取程序执行目录，比如需要加载配置文件，写入调试，错误日志等情况的时候。 go 程序在开发环境，生产环境，测试环境下的执行目录通常是不一样的，这样会导致不同情况下获取程序执行目录会变得比较麻烦。 接下来将要介绍 go 语言中几种常用的获取目录的几种方法，并介绍它们的相关特性。 os.Getwd() 返回相对当前目录之一的根路径 func GetCWD() string { cwd, _ := os.Getwd() return cwd } os.Executable() 返回当前进程的可执行文件绝对路径。路径会包含执行文件的名称,配合 filepath.Dir() 返回执行文件所在目录。 func GetExec() string { exePath, _ := os.Executable() exePath, _ := os.Executable() } os.TempDir() 返回存放临时文件的默认路径 func GetTempDir() string { return os.TempDir() } runtime.Caller 返回有关调用 goroutine 堆栈上的函数调用的文件和行号信息 // 返回有关调用 goroutine 堆栈上的函数调用的文件和行号信息 func GetCaller() (string, int) { _, filename, line, ok := runtime.Caller(0) if ok { return path.Dir(filename), line } return \"\", 0 } main.go 完整代码 package main import ( \"fmt\" \"github.com/snowlyg/learns/path/dir\" ) func main() { fmt.Printf(\"cwd path is %s\\n\", dir.GetCWD()) fmt.Printf(\"exec path is %s\\n\", dir.GetExec()) path, line := dir.GetCaller() fmt.Printf(\"caller filepath is %s\\ncaller line is %d\\n\", path, line) } dir/dir.go // 返回相对当前目录之一的根路径 func GetCWD() string { cwd, _ := os.Getwd() return cwd } // 返回当前进程的可执行文件绝对路径 func GetExec() string { exePath, _ := os.Executable() return filepath.Dir(exePath) } // 返回存放临时文件的默认路径 func GetTempDir() string { return os.TempDir() } // 返回有关调用 goroutine 堆栈上的函数调用的文件和行号信息 func GetCaller() (string, int) { _, filename, line, ok := runtime.Caller(0) if ok { return path.Dir(filename), line } return \"\", 0 } package dir import ( \"testing\" \"fmt\" ) func TestPath(t *testing.T) { t.Run(\"cwd path\", func(t *testing.T) { fmt.Printf(\"cwd path is %s\\n\", GetCWD()) fmt.Printf(\"exec path is %s\\n\", GetExec()) path, line := GetCaller() fmt.Printf(\"caller filepath is %s\\ncaller line is %d\\n\", path, line) }) } 接下来我们看下不同模式下，各个方法返回的数据 执行目录是 /Users/snowlyg/go/src/github.com/snowlyg/learns，执行 go run path/main.go 执行目录是 /Users/snowlyg/go/src/github.com/snowlyg/learns，执行 go build -o path/main path/main.go,然后执行 path/main 执行文件 执行目录是 /Users/snowlyg/go/src/github.com/snowlyg/learns，执行 go test -timeout 30s -v -run ^TestPath$ github.com/snowlyg/learns/path/dir ","date":"2021-07-11  14:23:13","objectID":"/dir/:0:0","tags":["Golang","dir"],"title":"Golang 程序中获取执行目录的几种方式","uri":"/dir/"},{"categories":["docker","PHP","mac"],"content":"简单使用 docker 配置开发环境,在 mac 环境下搭建 PHP环境","date":"2021-06-19  22:12:48","objectID":"/simple/","tags":["PHP","docker","redis","mysql","mac"],"title":"简单使用 docker 配置开发环境（mac+php）","uri":"/simple/"},{"categories":["docker","PHP","mac"],"content":"前言 搭建开发环境是一个开发者必备的技能，但是重复的搭建各种开发环境，依然是一件很无趣且浪费时间的事情。 以前的解决方案通常是虚拟机或者一些集成工具，它们能很好的解决重复搭建相同开发环境的问题。 同时它们也有着一些缺陷，比如虚拟机过于笨重，集成工具功能比较固定单一。 docker 等虚拟容器技术的出现，让开始构建多样的开发环境成为可能。 基础需求 安装 docker 安装 docker-compose windows 环境：需要win10 + wsl 子系统 ，参考 WIN10 系统下 WSL 配置 laravel 开发环境指南# 第一步 clone docker-compose 脚本,复制配置文件 # 克隆脚本 git clone https://github.com/snowlyg/dnmp #复制配置文件 copy docker-compose.sample.yml docker-compose.yml 根据自己需要的服务，修改配置文件解开或者加上对应的注释代码 php 基础开发环境nginx + mysql + redis 如下 version:\"3\"services:nginx:build:context:./services/nginxargs:NGINX_VERSION:1.15.7-alpineCONTAINER_PACKAGE_URL:mirrors.aliyun.comNGINX_INSTALL_APPS:\"\"container_name:nginxports:- \"80:80\"- \"443:443\"volumes:- ./www:/www/:rw- ./services/nginx/ssl:/ssl:rw- ./services/nginx/conf.d:/etc/nginx/conf.d/:rw- ./services/nginx/nginx.conf:/etc/nginx/nginx.conf:ro- ./services/nginx/fastcgi-php.conf:/etc/nginx/fastcgi-php.conf:ro- ./services/nginx/fastcgi_params:/etc/nginx/fastcgi_params:ro- ./logs/nginx:/var/log/nginx/:rwenvironment:TZ:\"Asia/Shanghai\"restart:alwaysnetworks:- defaultphp:build:context:./services/phpargs:PHP_VERSION:php:7.3-fpm-alpineCONTAINER_PACKAGE_URL:mirrors.aliyun.comPHP_EXTENSIONS:\"pdo_mysql,mysqli,mbstring,gd,curl,opcache,soap,amqp,bcmath,pcntl,redis,xdebug\"TZ:\"Asia/Shanghai\"container_name:phpexpose:- 9501extra_hosts:- \"www.site1.com:172.17.0.1\"volumes:- ./www:/www/:rw- ./services/php/php.ini:/usr/local/etc/php/php.ini:ro- ./services/php/php-fpm.conf:/usr/local/etc/php-fpm.d/www.conf:rw- ./logs/php:/var/log/php- ./data/composer:/tmp/composerrestart:alwayscap_add:- SYS_PTRACEnetworks:- default# php56:# build:# context: ./services/php# args:# PHP_VERSION: php:5.6.40-fpm-alpine# CONTAINER_PACKAGE_URL: mirrors.aliyun.com# PHP_EXTENSIONS: \"pdo_mysql,mysqli,mbstring,gd,curl,opcache\"# TZ: \"Asia/Shanghai\"# container_name: php56# expose:# - 9501# volumes:# - ./www:/www/:rw# - ./services/php/php.ini:/usr/local/etc/php/php.ini:ro# - ./services/php/php-fpm.conf:/usr/local/etc/php-fpm.d/www.conf:rw# - ./logs/php:/var/log/php# - ./data/composer:/tmp/composer# restart: always# cap_add:# - SYS_PTRACE# networks:# - default# php54:# build:# context: ./services/php54# args:# PHP_VERSION: php:5.4.45-fpm# CONTAINER_PACKAGE_URL: mirrors.aliyun.com# PHP_EXTENSIONS: \"pdo_mysql,mysqli,mbstring,gd,curl,opcache\"# TZ: \"Asia/Shanghai\"# container_name: php54# volumes:# - ./www:/www/:rw# - ./services/php54/php.ini:/usr/local/etc/php/php.ini:ro# - ./services/php54/php-fpm.conf:/usr/local/etc/php-fpm.d/www.conf:rw# - ./logs/php:/var/log/php# - ./data/composer:/tmp/composer# restart: always# cap_add:# - SYS_PTRACE# networks:# - defaultmysql:image:mysql:8.0.13container_name:mysqlports:- \"3306:3306\"volumes:- ./services/mysql/mysql.cnf:/etc/mysql/conf.d/mysql.cnf:ro- ./data/mysql:/var/lib/mysql/:rwrestart:alwaysnetworks:- defaultenvironment:MYSQL_ROOT_PASSWORD:\"123456\"TZ:\"Asia/Shanghai\"# mysql5:# image: mysql:5.7.28# container_name: mysql5# ports:# - \"3305:3306\"# volumes:# - ./services/mysql5/mysql.cnf:/etc/mysql/conf.d/mysql.cnf:ro# - ./data/mysql5:/var/lib/mysql/:rw# restart: always# networks:# - default# environment:# MYSQL_ROOT_PASSWORD: \"123456\"# TZ: \"Asia/Shanghai\"# openresty:# image: openresty/openresty:alpine# container_name: openresty# ports:# - \"80:80\"# - \"443:443\"# volumes:# - ./www:/www/:rw# - ./services/openresty/conf.d:/etc/nginx/conf.d/:ro# - ./services/openresty/openresty.conf:/ssl:rw# - ./services/openresty/fastcgi-php.conf:/usr/local/openresty/nginx/conf/nginx.conf:ro# - ./services/openresty/fastcgi_params:/usr/local/openresty/nginx/conf/fastcgi-php.conf:ro# - ./services/openresty/ssl:/usr/local/openresty/nginx/conf/fastcgi_params:ro# - ./logs/nginx:/var/log/nginx/:rw# environment:# TZ: \"Asia/Shanghai\"# networks:# - defaultredis:image:redis:5.0.3-alpinecontainer_name:redisports:- \"6379:6379\"volumes:- ./services/redis/redis.conf:/etc/redis.conf:ro- ./data/redis:/data/:rwrestart:alwaysentrypoint:[\"redis-server\",\"/etc/redis.conf\"]environment:TZ:\"Asia/Shanghai\"networks:- defau","date":"2021-06-19  22:12:48","objectID":"/simple/:0:0","tags":["PHP","docker","redis","mysql","mac"],"title":"简单使用 docker 配置开发环境（mac+php）","uri":"/simple/"},{"categories":["tools"],"content":"控制台窗口和powershell运行服务会卡住的解决办法","date":"2021-06-05  14:59:30","objectID":"/cmd/","tags":["tools","windows","powershell","cmd"],"title":"控制台窗口和powershell运行服务会卡住的解决办法","uri":"/cmd/"},{"categories":["tools"],"content":"问题描述 在 windows 环境下开发的时候，使用 `PowerShell` 执行 `go run main.go` 或者 `air` 等命令经常会出现程序会卡在的问题。 这时候需要到控制台按一下回车程序才会继续往下执行。 ","date":"2021-06-05  14:59:30","objectID":"/cmd/:0:1","tags":["tools","windows","powershell","cmd"],"title":"控制台窗口和powershell运行服务会卡住的解决办法","uri":"/cmd/"},{"categories":["tools"],"content":"原因和解决方法 原因：控制台开启了快速编辑模式的情况下，如果鼠标选中了文本之后就会出现这个情况。 解决方案：关闭控制台的快速编辑模式。 步骤： - 右键点击 PowerShell 左上角图标 - 取消快速编辑模式 - 确定 ","date":"2021-06-05  14:59:30","objectID":"/cmd/:0:2","tags":["tools","windows","powershell","cmd"],"title":"控制台窗口和powershell运行服务会卡住的解决办法","uri":"/cmd/"},{"categories":["tools"],"content":"如图 ","date":"2021-06-05  14:59:30","objectID":"/cmd/:0:3","tags":["tools","windows","powershell","cmd"],"title":"控制台窗口和powershell运行服务会卡住的解决办法","uri":"/cmd/"},{"categories":["Golang","PHP","Nodejs"],"content":"数据的压缩解压，大部分语言都是基于 zlib 这个库实现的，那么让不同语言之间数据压缩/解压实现成为了可能。","date":"2021-04-23  20:41:20","objectID":"/clizb/","tags":["Golang","PHP","Nodejs","zlib","compress","decompress"],"title":"不同语言之间数据压缩/解压实现","uri":"/clizb/"},{"categories":["Golang","PHP","Nodejs"],"content":"文章源码地址：https://www.github.com/snowlyg/learns 不同语言之间数据压缩/解压实现 正常的时候，使用一种编程语言实现数据的压缩、解压都十分简单。 golang 有如下 5 个基础包 compress/gzip compress/bzip2 compress/flate compress/lzw compress/zlib chindeo/czlib php 有如下 6 个压缩、解压格式 bzip2 lzf phar rar zip zlib nodejs 主要使用 zlib 压缩、解压格式 zlib 三种语言都有 zlib 方式的压缩、解压方式，这样选择 zlib 方式来做不同编程语言间的压缩，解压方式比较合适。 data.json 文件 { \"fdafddsf\":\"e324r324e324e\", \"fd111afddsf\":\"e324r324e324e\" } golang 实现 zlib package main import ( \"bytes\" \"fmt\" \"io\" \"os\" \"path\" \"github.com/chindeo/czlib\" ) func main() { // 提取文件内容 f, err := os.Open(\"./data.json\") if err != nil { fmt.Printf(\"os open %v\\n\", err) return } // 压缩内容 var b bytes.Buffer w, err := czlib.NewWriterLevel(\u0026b, -1) if err != nil { fmt.Printf(\"flate new writer %v\\n\", err) return } defer w.Close() _, err = io.Copy(w, f) if err != nil { fmt.Printf(\"zlib new reader %v\", err) return } w.Flush() // 将压缩后内容写入文件 _, err = writeBytes(\"./data.zip\", b.Bytes()) if err != nil { fmt.Printf(\"WriteBytes %v\\n\", err) return } // 解压内容 r, err := czlib.NewReader(\u0026b) if err != nil { fmt.Printf(\"NewReader %v\\n\", err) return } defer r.Close() _, err = io.Copy(os.Stdout, r) if err != nil { fmt.Printf(\"io copy %v\\n\", err) return } } func writeBytes(filePath string, b []byte) (int, error) { os.MkdirAll(path.Dir(filePath), os.ModePerm) fw, err := os.Create(filePath) if err != nil { return 0, err } defer fw.Close() return fw.Write(b) } 执行 go run main.go 得到 data.zip 文件 nodejs 实现 zlib compress.js const { createDeflate } = require('zlib'); const { pipeline } = require('stream'); const { createReadStream, createWriteStream } = require('fs'); const gzip = createDeflate(); const source = createReadStream('data.json'); const destination = createWriteStream('data.zip'); pipeline(source, gzip, destination, (err) =\u003e { if (err) { console.error('发生错误:', err); process.exitCode = 1; } }); decompress.js const { createInflate } = require('zlib'); const { pipeline } = require('stream'); const { createReadStream, createWriteStream } = require('fs'); const gunzip = createInflate(); const sourceUnzip = createReadStream('data.zip'); const destinationUnzip = createWriteStream('data.txt'); pipeline(sourceUnzip, gunzip, destinationUnzip, (err) =\u003e { if (err) { console.error('发生错误:', err); process.exitCode = 1; } }); 执行 node compress.js 得到 data.zip 文件 执行 node decompress.js 解压 data.zip 文件 php 实现 zlib \u003c?php // Perform GZIP compression: $compressed = file_get_contents(\"data.json\"); $deflateContext = deflate_init(ZLIB_ENCODING_DEFLATE); $compressed = deflate_add($deflateContext, $compressed, ZLIB_NO_FLUSH); $compressed .= deflate_add($deflateContext, NULL, ZLIB_FINISH); file_put_contents(\"data.zip\",$compressed); // Perform GZIP decompression: $inflateContext = inflate_init(ZLIB_ENCODING_DEFLATE); $uncompressed = inflate_add($inflateContext, $compressed, ZLIB_NO_FLUSH); $uncompressed .= inflate_add($inflateContext, NULL, ZLIB_FINISH); echo $uncompressed; ?\u003e?\u003e 执行 php index.php 得到 data.zip 文件 目前已经实现了三种语言各自的压缩，解压数据。 因为实现比较简单就没有贴语言间交叉压缩，解压数据的代码了。具体源码参考在：learns/zlib · PHP 解压 GO 压缩文件 decompress_with_go_compress .php \u003c?php // Perform GZIP compression: $compressed = file_get_contents(\"../go/data.zip\"); $inflateContext = inflate_init(ZLIB_ENCODING_DEFLATE); $uncompressed = inflate_add($inflateContext, $compressed, ZLIB_NO_FLUSH); $uncompressed .= inflate_add($inflateContext, NULL, ZLIB_FINISH); file_put_contents(\"go_data.json\",$uncompressed); echo $uncompressed; ?\u003e PHP 解压 NODEJS 压缩文件 decompress_with_nodejs_compress .php \u003c?php // Perform GZIP compression: $compressed = file_get_contents(\"../nodejs/data.zip\"); $inflateContext = inflate_init(ZLIB_ENCODING_DEFLATE); $uncompressed = inflate_add($inflateContext, $compressed, ZLIB_NO_FLUSH); $uncompressed .= inflate_add($inflateContext, NULL, ZLIB_FINISH); file_put_contents(\"go_data.json\",$uncompressed); echo $uncompressed; ?\u003e NODEJS 解压 PHP 压缩文件 decompress_with_php_compress.js const { createInflate } = require('zlib'); const { pipeline } = require('stream'); const { createReadStream, createWrite","date":"2021-04-23  20:41:20","objectID":"/clizb/:0:0","tags":["Golang","PHP","Nodejs","zlib","compress","decompress"],"title":"不同语言之间数据压缩/解压实现","uri":"/clizb/"},{"categories":["Golang","Reflection"],"content":"golang 基于反射原理实现简单实现数据转换格式化","date":"2021-04-23  20:35:37","objectID":"/gotransformer/","tags":["Golang","Reflection","transformer"],"title":"golang 简单实现数据转换格式化","uri":"/gotransformer/"},{"categories":["Golang","Reflection"],"content":"golang 简单实现数据转换格式化 https://github.com/snowlyg/gotransformer go-transformer 更新日志 更新日志 Require go 1.13.x 支持格式化方式 简单格式化 自定义方法格式化 关联数据格式化 时间数据格式化 map数据格式化 excel 导入数据格式化 ","date":"2021-04-23  20:35:37","objectID":"/gotransformer/:0:0","tags":["Golang","Reflection","transformer"],"title":"golang 简单实现数据转换格式化","uri":"/gotransformer/"},{"categories":["Golang","Reflection"],"content":"Installation go get -u github.com/snowlyg/gotransformer ","date":"2021-04-23  20:35:37","objectID":"/gotransformer/:1:0","tags":["Golang","Reflection","transformer"],"title":"golang 简单实现数据转换格式化","uri":"/gotransformer/"},{"categories":["learns"],"content":"并发通道篇-控制 windows 服务","date":"2021-03-26  20:02:48","objectID":"/channel/","tags":["Golang","learns"],"title":"学习篇-并发通道","uri":"/channel/"},{"categories":["learns"],"content":"控制 windows 服务 文章源码地址：https://www.github.com/snowlyg/learns 这一篇将介绍如何远程控制服务，通过一个心跳机制，每隔一段时间检测一个服务是否需要更新，停止，启动等操作。 然后通过得到的信息和指令来操控服务。 大概的思路就是通过并发和通道特性来实现。并发和通道都是 go 很重要的特性，学会如何运用它们很有必要。 启动一个简单的协程 用 go 关键字很简单就可以启动一个协程。 这个协程每隔 5 秒打印一次当前时间 package main import ( \"time\" ) func hearbeat() { for { println(time.Now().Format(time.RFC3339)) time.Sleep(time.Second * 5) } } func main() { go hearbeat() // 防止主进程退出 select {} } 新建一个容量为1的通道，每隔 5 秒发送一个操作指令到通道 package main import ( \"time\" ) // actionChan 容量为 1 的通道，在 hearbeat , do 两个协程中传递指令信息 // 容量为 1 可以控制并发的数量，只有等发送的指令被处理后才能发送另一个指令 var actionChan = make(chan string, 1) func hearbeat() { for { // TODO： 这里需要做处理写死了 update，正常这里需要请求某个接口返回得到一个操作指令 action := \"update\" actionChan \u003c- action // 休眠 5 秒 println(time.Now().Format(time.RFC3339)) time.Sleep(time.Second * 5) } } func main() { go hearbeat() // 防止主进程退出 select {} } 通道容量为 1 ,发送一个指令后如果指令没有处理。 没那么将无法再向通道发送指令，hearbeat 会被阻塞直到指令被处理通道才能从新接受新的指令。 新建一个新的协程接受指令，并执行相应的操作。 package main import ( \"fmt\" \"time\" \"github.com/snowlyg/learns/advance/windows\" ) // actionChan 容量为 1 的通道，在 hearbeat , do 两个协程中传递指令信息 // 容量为 1 可以控制并发的数量，只有等发送的指令被处理后才能发送另一个指令 var actionChan = make(chan string, 1) // hearbeat 每隔 5 秒返回一个操作 func hearbeat() { for { // TODO： 这里需要做处理写死了 update，正常这里需要请求某个接口返回得到一个操作指令 action := \"update\" actionChan \u003c- action // 休眠 5 秒 println(time.Now().Format(time.RFC3339)) time.Sleep(time.Second * 5) } } // 执行操作，从通道 actionChan 获取对应指令并执行对应操作 func do() { for { switch \u003c-actionChan { case \"start\": err := windows.ServiceStart(\"myservice\") if err != nil { fmt.Printf(\"start myservice %v\", err) } println(\"start\") case \"stop\": err := windows.ServiceStop(\"myservice\") if err != nil { fmt.Printf(\"stop myservice %v\", err) } println(\"stop\") case \"install\": err := windows.ServiceInstall(\"myservice\", \"../cmd/myservice.exe\", \"myservice\") if err != nil { fmt.Printf(\"install myservice %v\", err) } println(\"install\") case \"uninstall\": err := windows.ServiceUninstall(\"myservice\") if err != nil { fmt.Printf(\"uninstall myservice %v\", err) } println(\"uninstall\") case \"update\": err := windows.ServiceStop(\"myservice\") if err != nil { fmt.Printf(\"stop myservice %v\", err) } err = windows.ServiceUninstall(\"myservice\") if err != nil { fmt.Printf(\"uninstall myservice %v\", err) } err = windows.ServiceInstall(\"myservice\", \"myservice.exe\", \"myservice\") if err != nil { fmt.Printf(\"install myservice %v\", err) } println(\"update\") default: println(\"unknow action\") } } } func main() { // 启动一个心跳协程，每隔5秒发送指令 go hearbeat() // 启动一个执行命令协程，并等待心跳协程发送指令 go do() // 防止主进程退出 select {} } 新的 do 协程从通道中取出指令，并执行对应的指令。 这个程序中 hearbeat 和 do 两个方法不会安装原有的执行顺序方式执行。 增加了 go 关键字的修饰后，它们同时都在执行中，一个向通道 actionChan 中发送数据， 一个从通道 actionChan 中取出数据。 通过这个程序，我们就能远程控制某个或者多个服务了。 这个在我们需要远程更新或者控制多个服务器上的服务程序时非常有用。 只需要在本地执行操作，而不用一个个登录远程服务器操作。 ","date":"2021-03-26  20:02:48","objectID":"/channel/:0:0","tags":["Golang","learns"],"title":"学习篇-并发通道","uri":"/channel/"},{"categories":["learns"],"content":"进阶篇-注册 windows 服务","date":"2021-03-26  20:02:48","objectID":"/advance/","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"注册 windows 服务 文章源码地址：https://www.github.com/snowlyg/learns 将前面的程序注册成 windows 服务有多种方式： 使用 nssm.exe 执行 nssm.exe install myservice 使用 https://github.com/kardianos 项目,如何使用参考 example 还有 srvany.exe 等等 其中 https://github.com/kardianos 比较适合实现自动更新项目的需求，这个项目是兼容 linux 、mac windows 等多个系统环境的。但是我们只需要 windows 系统环境，如果是其他环境下更新一个程序其实并不需要这么麻烦。 查看源码能看到 windwos 系统使用的是这个包 golang.org/x/sys/windows , 用这个包简单的写一个新的 package。 项目目录下新建 windows 文件夹，并新建7个文件: service.go beep.go install.go start.go stop.go status.go uninstall.go ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:1","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"service.go 文件 package windows import ( \"fmt\" \"os\" \"os/signal\" \"time\" \"golang.org/x/sys/windows/svc\" \"golang.org/x/sys/windows/svc/debug\" \"golang.org/x/sys/windows/svc/eventlog\" ) var ( elog debug.Log interactive = false ) // init 初始化 // IsAnInteractiveSession 判断程序是否运行在交互模式 // 此方法说是要被废弃了，后期要使用 isWindowsService 代替 // 不过我使用次方法无法正常启动注册好的程序 func init() { var err error interactive, err = svc.IsAnInteractiveSession() if err != nil { panic(err) } } // Interface type Interface interface { Start() error Stop() error } // WindowsService type WindowsService struct { Name string i Interface } // NewWindowsService new一个服务对象 // name 服务名称 func NewWindowsService(i Interface, name string) (*WindowsService, error) { ws := \u0026WindowsService{ i: i, Name: name, } return ws, nil } // Execute 服务执行方法，控制服务启动停止 func (ws *WindowsService) Execute(args []string, r \u003c-chan svc.ChangeRequest, changes chan\u003c- svc.Status) (bool, uint32) { const cmdsAccepted = svc.AcceptStop | svc.AcceptShutdown changes \u003c- svc.Status{State: svc.StartPending} if err := ws.i.Start(); err != nil { elog.Info(1, fmt.Sprintf(\"%s service start failed: %v\", ws.Name, err)) return true, 1 } changes \u003c- svc.Status{State: svc.Running, Accepts: cmdsAccepted} loop: for { c := \u003c-r switch c.Cmd { case svc.Interrogate: changes \u003c- c.CurrentStatus case svc.Stop: changes \u003c- svc.Status{State: svc.StopPending} if err := ws.i.Stop(); err != nil { elog.Info(1, fmt.Sprintf(\"%s service stop failed: %v\", ws.Name, err)) return true, 2 } break loop case svc.Shutdown: changes \u003c- svc.Status{State: svc.StopPending} err := ws.i.Stop() if err != nil { elog.Info(1, fmt.Sprintf(\"%s service shutdown failed: %v\", ws.Name, err)) return true, 2 } break loop default: continue loop } } return false, 0 } func (ws *WindowsService) Run(isDebug bool) error { var err error if !interactive { if isDebug { elog = debug.New(ws.Name) } else { elog, err = eventlog.Open(ws.Name) if err != nil { return err } } defer elog.Close() elog.Info(1, fmt.Sprintf(\"starting %s service\", ws.Name)) run := svc.Run if isDebug { run = debug.Run } err = run(ws.Name, ws) if err != nil { elog.Error(1, fmt.Sprintf(\"%s service failed: %v\", ws.Name, err)) return err } elog.Info(1, fmt.Sprintf(\"%s service stopped\", ws.Name)) } err = ws.i.Start() if err != nil { return err } sigChan := make(chan os.Signal) signal.Notify(sigChan, os.Interrupt) \u003c-sigChan return ws.i.Stop() } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:2","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"beep.go 文件 package windows import ( \"syscall\" ) // BUG(brainman): MessageBeep Windows api is broken on Windows 7, // so this example does not beep when runs as service on Windows 7. var ( beepFunc = syscall.MustLoadDLL(\"user32.dll\").MustFindProc(\"MessageBeep\") ) func beep() { beepFunc.Call(0xffffffff) } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:3","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"install.go 文件 package windows import ( \"fmt\" \"golang.org/x/sys/windows/svc/eventlog\" \"golang.org/x/sys/windows/svc/mgr\" ) func ServiceInstall(svcName, execPath, dispalyName string, args ...string) error { m, err := mgr.Connect() if err != nil { return err } defer m.Disconnect() s, err := m.OpenService(svcName) if err == nil { s.Close() return fmt.Errorf(\"service %s already exists\", svcName) } config := mgr.Config{ DisplayName: dispalyName, StartType: mgr.StartAutomatic, } if len(args) \u003e= 2 { config.ServiceStartName = args[0] config.Password = args[1] } s, err = m.CreateService(svcName, execPath, config) if err != nil { return fmt.Errorf(\"CreateService() failed: %s\", err) } defer s.Close() err = eventlog.InstallAsEventCreate(svcName, eventlog.Error|eventlog.Warning|eventlog.Info) if err != nil { s.Delete() return fmt.Errorf(\"InstallAsEventCreate() failed: %s\", err) } return nil } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:4","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"start.go 文件 package windows import ( \"golang.org/x/sys/windows/svc/mgr\" ) func ServiceStart(srcName string) error { m, err := mgr.Connect() if err != nil { return err } defer m.Disconnect() s, err := m.OpenService(srcName) if err != nil { return err } defer s.Close() return s.Start() } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:5","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"status.go 文件 package windows import ( \"errors\" \"fmt\" \"golang.org/x/sys/windows/svc\" \"golang.org/x/sys/windows/svc/mgr\" ) type Status byte const ( StatusUnknown Status = iota // Status is unable to be determined due to an error or it was not installed. StatusRunning StatusStopped StatusUninstall ) var ( // ErrNameFieldRequired is returned when Config.Name is empty. ErrNameFieldRequired = errors.New(\"Config.Name field is required.\") // ErrNoServiceSystemDetected is returned when no system was detected. ErrNoServiceSystemDetected = errors.New(\"No service system detected.\") // ErrNotInstalled is returned when the service is not installed ErrNotInstalled = errors.New(\"the service is not installed\") ) // status func ServiceStatus(srcName string) (Status, error) { m, err := mgr.Connect() if err != nil { return StatusUnknown, err } defer m.Disconnect() s, err := m.OpenService(srcName) if err != nil { if err.Error() == \"The specified service does not exist as an installed service.\" { return StatusUninstall, nil } return StatusUnknown, err } defer s.Close() status, err := s.Query() if err != nil { return StatusUnknown, err } switch status.State { case svc.StartPending: fallthrough case svc.Running: return StatusRunning, nil case svc.PausePending: fallthrough case svc.Paused: fallthrough case svc.ContinuePending: fallthrough case svc.StopPending: fallthrough case svc.Stopped: return StatusStopped, nil default: return StatusUnknown, fmt.Errorf(\"unknown status %v\", status) } } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:6","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"stop.go 文件 package windows import ( \"strconv\" \"time\" \"golang.org/x/sys/windows/registry\" \"golang.org/x/sys/windows/svc\" \"golang.org/x/sys/windows/svc/mgr\" ) func ServiceStop(srcName string) error { m, err := mgr.Connect() if err != nil { return err } defer m.Disconnect() s, err := m.OpenService(srcName) if err != nil { return err } defer s.Close() return stopWait(s) } func stopWait(s *mgr.Service) error { // First stop the service. Then wait for the service to // actually stop before starting it. status, err := s.Control(svc.Stop) if err != nil { return err } timeDuration := time.Millisecond * 50 timeout := time.After(getStopTimeout() + (timeDuration * 2)) tick := time.NewTicker(timeDuration) defer tick.Stop() for status.State != svc.Stopped { select { case \u003c-tick.C: status, err = s.Query() if err != nil { return err } case \u003c-timeout: break } } return nil } // getStopTimeout fetches the time before windows will kill the service. func getStopTimeout() time.Duration { // For default and paths see https://support.microsoft.com/en-us/kb/146092 defaultTimeout := time.Millisecond * 20000 key, err := registry.OpenKey(registry.LOCAL_MACHINE, `SYSTEM\\CurrentControlSet\\Control`, registry.READ) if err != nil { return defaultTimeout } sv, _, err := key.GetStringValue(\"WaitToKillServiceTimeout\") if err != nil { return defaultTimeout } v, err := strconv.Atoi(sv) if err != nil { return defaultTimeout } return time.Millisecond * time.Duration(v) } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:7","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"uninstall.go 文件 package windows import ( \"fmt\" \"golang.org/x/sys/windows/svc/eventlog\" \"golang.org/x/sys/windows/svc/mgr\" ) func ServiceUninstall(srcName string) error { m, err := mgr.Connect() if err != nil { return err } defer m.Disconnect() s, err := m.OpenService(srcName) if err != nil { return fmt.Errorf(\"service %s is not installed\", srcName) } defer s.Close() err = s.Delete() if err != nil { return err } err = eventlog.Remove(srcName) if err != nil { return fmt.Errorf(\"RemoveEventLogSource() failed: %s\", err) } return nil } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:8","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"修改前面的 main.go 文件 package main import ( \"fmt\" \"os\" \"strings\" \"time\" \"github.com/snowlyg/learns/advance/windows\" ) func run() { // 每隔 5 秒打印当前时间 ticker := time.NewTicker(5 * time.Second) defer ticker.Stop() // for 循环阻塞程序主进程 // ticker.C 通道每隔五秒会发送一个值 for { \u003c-ticker.C // 格式化时间 now := time.Now().Format(time.RFC3339) fmt.Printf(\"当前时间：%s \\n\", now) } } func (p *program) Start() error { go run() return nil } func (p *program) Stop() error { //stop return nil } type program struct{} // usage 获取终端输入参数 func usage(errmsg string) { fmt.Fprintf(os.Stderr, \"%s\\n\\n\"+ \"usage: %s \u003ccommand\u003e \u003cservicename\u003e\\n\"+ \" where \u003ccommand\u003e is one of\\n\"+ \" install, remove, start, stop, status .\\n\"+ \" and use install : .\\n\"+ \" install \u003cservice name\u003e \u003cexec path\u003e \u003cdisplay name\u003e \u003csystem name\u003e \u003cpassword\u003e \\n\", errmsg, os.Args[0]) os.Exit(2) } func main() { // new 一个服务 s, err := windows.NewWindowsService(\u0026program{}, \"myservice\") if err != nil { fmt.Printf(\"new service get error %v \\n\", err) } if len(os.Args) \u003e= 2 { srvName := strings.ToLower(os.Args[2]) cmd := strings.ToLower(os.Args[1]) switch cmd { case \"start\": // 启动 err := windows.ServiceStart(srvName) if err != nil { fmt.Printf(\"%v \\n\", err) } println(\"start success\") return case \"install\": //安装 if len(os.Args) == 7 { err := windows.ServiceInstall(srvName, os.Args[3], os.Args[4], os.Args[5], os.Args[6]) if err != nil { fmt.Printf(\"%v \\n\", err) } } else if len(os.Args) == 5 { err := windows.ServiceInstall(srvName, os.Args[3], os.Args[4]) if err != nil { fmt.Printf(\"%v \\n\", err) } } else { usage(\"error command specified\") } println(\"install success\") return case \"stop\": // 停止 err := windows.ServiceStop(srvName) if err != nil { fmt.Printf(\"%v \\n\", err) } println(\"stop success\") return case \"remove\": // 卸载 err := windows.ServiceUninstall(srvName) if err != nil { fmt.Printf(\"%v \\n\", err) } println(\"remove success\") return case \"status\": // 查询服务状态 status, _ := windows.ServiceStatus(srvName) if status == windows.StatusRunning { println(\"运行中\") } else if status == windows.StatusStopped { println(\"已停止\") } else if status == windows.StatusUninstall { println(\"未安装\") } else if status == windows.StatusUninstall { println(\"未安装\") } return default: println(\"invaild command\") } switch cmd { case \"start\": // 启动 err := windows.ServiceStart(srvName) if err != nil { fmt.Printf(\"%v \\n\", err) } println(\"start success\") return case \"install\": //安装 if len(os.Args) == 7 { err := windows.ServiceInstall(srvName, os.Args[3], os.Args[4], os.Args[5], os.Args[6]) if err != nil { fmt.Printf(\"%v \\n\", err) } } else if len(os.Args) == 5 { err := windows.ServiceInstall(srvName, os.Args[3], os.Args[4]) if err != nil { fmt.Printf(\"%v \\n\", err) } } else { usage(\"error command specified\") } println(\"install success\") return case \"stop\": // 停止 err := windows.ServiceStop(srvName) if err != nil { fmt.Printf(\"%v \\n\", err) } println(\"stop success\") return case \"remove\": // 卸载 err := windows.ServiceUninstall(srvName) if err != nil { fmt.Printf(\"%v \\n\", err) } println(\"remove success\") return case \"status\": // 查询服务状态 status, _ := windows.ServiceStatus(srvName) if status == windows.StatusRunning { println(\"运行中\") } else if status == windows.StatusStopped { println(\"已停止\") } else if status == windows.StatusUninstall { println(\"未安装\") } else if status == windows.StatusUnknown { println(\"未知状态\") } return default: println(\"invaild command\") } } s.Run(false) } ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:9","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"打包文件 再次打包程序 go build -o myservice.exe main.go 生成 myservice.exe 文件。 可以通过如下命令行控制服务： # 注册服务，有七个参数 服务名称、服务文件路径、服务显示名称、系统账号、系统密码 # 只有 服务名称、服务文件路径 为必选参数，其他为可选参数 # 有账号密码 .\\cmd\\advance.exe install myservice \"C:\\Users\\Administrator\\go\\src\\github.com\\snowlyg\\learns\\cmd\\advance.exe\" myservice \".\\Administrator\" \"123456\" # 没账号密码 .\\cmd\\advance.exe install myservice \"C:\\Users\\Administrator\\go\\src\\github.com\\snowlyg\\learns\\cmd\\advance.exe\" myservice # 启动服务 .\\cmd\\advance.exe start myservice # 停止服务 .\\cmd\\advance.exe stop myservice # 卸载服务 .\\cmd\\advance.exe remove myservice # 查询服务状态 .\\cmd\\advance.exe status myservice ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:10","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"小坑 这里有个小坑：当使用账号（administrator）、密码(123456)参数注册服务的时候，启动的时候会提示账号密码错误。这个问题我各种看源码、各种搜索都没有解决问题。最后无意中看到了这个文档https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicea 这个文档我有找了几个小时才找到，毕竟已经过了好几天了。仔细看这个文档会发现这样描述： 就是最后一行，注册服务获取系统授权需要使用 .\\Administrator 。 最后吐槽一下：windows 的文档是真的难找。 ","date":"2021-03-26  20:02:48","objectID":"/advance/:0:11","tags":["Golang","learns"],"title":"学习篇-进阶","uri":"/advance/"},{"categories":["learns"],"content":"基础篇-编写一个简单的go程序","date":"2021-03-22  21:17:27","objectID":"/base/","tags":["Golang","learns"],"title":"学习篇-基础","uri":"/base/"},{"categories":["learns"],"content":"这一篇主要介绍如何编写一个简单的 go 程序，并将它注册成为一个 windows 系统服务。 文章源码地址：https://www.github.com/snowlyg/learns 简单程序 package main import ( \"fmt\" \"time\" ) func main() { // 每隔 5 秒打印当前时间 ticker := time.NewTicker(5 * time.Second) defer ticker.Stop() // for 循环阻塞程序主进程 // ticker.C 通道每隔五秒会发送一个值 for { \u003c-ticker.C // 格式化时间 now := time.Now().Format(time.RFC3339) fmt.Printf(\"当前时间：%s \\n\", now) } } 在终端执行 go run main.go ,每隔5秒钟会打印打印出当前的时间： 打包 exe 执行文件 运行 go build -o myservice.exe main.go 将程序打包成 exe 执行文件。项目目录下会生成一个 myservice.exe 文件。 ","date":"2021-03-22  21:17:27","objectID":"/base/:0:0","tags":["Golang","learns"],"title":"学习篇-基础","uri":"/base/"},{"categories":["learns"],"content":"前言篇-随便写一些闲话","date":"2021-03-19  22:49:30","objectID":"/start/","tags":["Golang","learns"],"title":"学习篇-前言","uri":"/start/"},{"categories":["learns"],"content":"前言 从 2019 年底接触 go 这门新的编程语言到 2021 年初已经有 1 年多的时间了。 在 2020 这一年的大多时间里，我都在忙于技术转型，人也变得心浮气躁。 自身的积累不够，自然会四处碰壁。 2021 新的一年，重新开这个博客小站。 希望多写一些学习的心得、多记录一些学习的方法、多认识一些的朋友、多一份成长。 从这一篇文章开始，会介绍一个简单的小项目的开发过程。 从项目需求的前期梳理和查找相关技术难点的参考项目，然后到开发过程中的一些问题的解决思路。 慢慢调整项目的架构，直至让项目在自己技术的理解范围内完美的呈现。 注意：这里说的完美呈现，并不是说这个项目真的没有任何问题。只是说在个人的技术经验下，让这个项目做到做到最好。 ","date":"2021-03-19  22:49:30","objectID":"/start/:0:1","tags":["Golang","learns"],"title":"学习篇-前言","uri":"/start/"},{"categories":["learns"],"content":"新的需求 目前有一个这样的需求： 基于 windows 的系统环境下，给超过 100 台设备部署一个客户端应用。 该客户端会执行一些任务，比如采集设备CPU,内存等运行指标、或者运行一个 web 应用。 要求此客户端必须以管理员权限作为服务运行在目标设备。 客户端需要有自动更新的能力，每次更新如果都要运维人员手动更新。 这将是一个巨大的工作量。如果更新比较频繁，运维人员可能会崩溃。 ","date":"2021-03-19  22:49:30","objectID":"/start/:0:2","tags":["Golang","learns"],"title":"学习篇-前言","uri":"/start/"},{"categories":["learns"],"content":"分解需求 实现以上需求分解大致是一下几部分： 实现一个程序并将它注册成一个 windows 系统服务。 实现一个管理程序版本的后台，并提供检查程序版本和下载程序的接口。 实时监控该程序是否更新，如果有新的版本就更新程序。 ","date":"2021-03-19  22:49:30","objectID":"/start/:0:3","tags":["Golang","learns"],"title":"学习篇-前言","uri":"/start/"},{"categories":["Golang","IRIS"],"content":"简单介绍iris+casbin从陌生到学会使用的过程详细","date":"2021-03-06  17:10:32","objectID":"/iris-go-api-2/","tags":["Golang","IRIS","Api"],"title":"iris + casbin 从陌生到学会使用的过程","uri":"/iris-go-api-2/"},{"categories":["Golang","IRIS"],"content":"前言 前面写了一篇 【iris-go 框架构建登陆 API 项目开发过程】 的文章，因为篇幅的关系文章并没有介绍如何实现权限控制。接下来我将会介绍如何使用 casbin 在 iris 的项目中实现权限控制，项目采用 grom 做数据处理。 本文纯属个人简陋观点和经验，如果有错误的地方，欢迎大家指出。 这里继续讲一些废话，原本 IrisAdminApi 项目采用的最原始的 RBAC 的权限控制实现，分别创建 roles ， permissions 表，然后定义关联关系，写一些关联创建逻辑。在实现的过程发现不管是使用 gorm ，xorm，beego的orm，定义关联关系都挺麻烦的，特别是多对对关系，还有一些多态关系等等。可能 Laravel 使用习惯性了，发现框架功能太齐全，对自身的提升真的会有阻碍。 这时候我就想有没有别人实现好的权限控制轮子，结果一顿搜索，让我找到了 casbin。这就是我和 casbin 的初识了。 刚见到 casbin 其实有些不知道如何下手，毕竟没有见过类似的项目。相信很多新手也会有同样的感受。不过没关系，一回生两回熟，像我们这样经过九年义务教育的社会主义好青年，最不怕的就是学习新事物。 大致介绍下我学习 casbin 的思路： 首先：看文档，就像买了新东西看说明书一样，学习任何新事物必不可少的一步。不需要完全背下来，大致有个印象就好。不懂的地方可以多看几遍，不要怕麻烦。 接下来：在文档中找到我们需要的功能，我们需要的是一个与 gorm 工作的 RBAC 权限控制，正好我发现作者有写 gorm 相关的适配器，其实作者为不同语言写非常多的适配器，这样可以省去我们的很多时间。 打开 gorm-adapter 项目，按照说明执行安装适配器： go get github.com/casbin/gorm-adapter 查看实例代码，很多项目多有实例代码，其实这些代码的价值比文档的价值更高，能让我们更好的理解项目。特别是注释，需要仔细看完。 package main import ( \"github.com/casbin/casbin/v2\" gormadapter \"github.com/casbin/gorm-adapter/v2\" _ \"github.com/go-sql-driver/mysql\" ) func main() { // 初始化一个 Gorm 适配器并且在一个 Casbin enforcer 中使用它: // 这个适配器会使用一个名为 \"casbin\" 的 MySQL 数据库。 // 如果数据库不存在，适配器会自动创建它。 // 你同样也可以像这样 gormadapter.NewAdapterByDB(gormInstance) 使用一个已经存在的 gorm 实例。 a := gormadapter.NewAdapter(\"mysql\", \"mysql_username:mysql_password@tcp(127.0.0.1:3306)/\") //你的驱动和数据源 e, _ := casbin.NewEnforcer(\"examples/rbac_model.conf\", a) // 或者你可以像这样使用一个其他的数据库 \"abc\" : // 适配器会使用名为 \"casbin_rule\" 的数据表。 // 如果数据表不存在，适配器会自动创建它。 // a := gormadapter.NewAdapter(\"mysql\", \"mysql_username:mysql_password@tcp(127.0.0.1:3306)/abc\", true) // 从数据库加载策略规则 e.LoadPolicy() // 检查权限 e.Enforce(\"alice\", \"data1\", \"read\") // 更新策略 // e.AddPolicy(...) // e.RemovePolicy(...) // 保存策略到数据库 e.SavePolicy() } 看完这个实例的代码和注释，相信你已经了解 casbin 怎么使用了。如果还不了解，那就多看几遍。 在看文档的过程中发现作者已经写好了 RBAC 相关的 API 。所以我们并不需要去重复的这些工作。你没有看到？这说明了仔细看文档的重要的性。 现在我们接着前面的项目，将 casbin 功能添加到项目中。编辑 models/base.go 文件： var Db *gorm.DB var err error var dirverName string var conn string var Enforcer *casbin.Enforcer func Register() { dirverName = \"mysql\" if isTestEnv() { //如果是测试使用测试数据库 conn = \"root:wemT5ZNuo074i4FNsTwl4KhfVSvOlBcF@(127.0.0.1:3306)/tiris\" } else { conn = \"root:wemT5ZNuo074i4FNsTwl4KhfVSvOlBcF@(127.0.0.1:3306)/iris\" } //初始化数据库 Db, err = gorm.Open(dirverName, conn+\"?charset=utf8\u0026parseTime=True\u0026loc=Local\") if err != nil { color.Red(fmt.Sprintf(\"gorm open 错误: %v\", err)) } a := gormadapter.NewAdapter(\"mysql\",conn) Enforcer, _ = casbin.NewEnforcer(\"examples/rbac_model.conf\", a) Enforcer.LoadPolicy() } 这里我们不需要生成新的 casbin 数据库，直接使用在 iris 数据库生成 casbin_rule 数据表。同时将 rbac_model.conf 文件复制到自己的项目的对应路径中。这样 casbin 就已经集成好了，重启项目就会生成对应的 casbin_rule 数据表了。 为什么没有使用 e.AddPolicy(…)，e.SavePolicy()，e.Enforce(“alice”, “data1”, “read”) 这些方法？ 如果你还有这样的疑问，说明你没有看实例的注释，要么就是没有仔细阅读。请多看几遍。 虽然我们已经集成了 casbin ，但是我们还没有实现权限控制的目的。如果实现？我们需要关联角色，权限等数据到用户，并且在用户访问相应资源的时候检查用户是否拥有权限。 到这里有经验的朋友就会发现，我们需要一个中间件去实现用户权限的检测。那么我们移驾到 iris 的中间件文档，我们仔细的看以遍文档，你会发现已经有了 casbin 的中间件实现。并不需要我们自己编写。 接着来到 middleware/tree/master/casbin 按照说明文档，先安装 casbin 还有 casbin-middleware，分别执行一下命令： go get github.com/casbin/casbin go get github.com/iris-contrib/middleware/casbin 然后按照实例中的代码将中间件添加到路由： package routers import ( \"IrisAdmin/controllers\" \"IrisAdmin/middleware\" \"IrisAdmin/models\" \"github.com/kataras/iris/v12\" \"github.com/casbin/casbin/v2\" cm \"github.com/iris-contrib/middleware/casbin\" ) func Register(app *iris.Application) { // 路由集使用跨域中间件 CrsAuth() // 允许 Options 方法 AllowMethods(iris.MethodOptions) main := app.Party(\"/\", middleware.CrsAuth()).AllowMethods(iris.MethodOptions) { v1 := main.Party(\"/v1\") { v1.Post(\"/admin/login\", controllers.UserLogin) v1.PartyFunc(\"/admin\", func(admin iris.Party) { casbinMiddleware := cm.New(models.Enforcer) admin.Use(middleware.JwtHandler().Serve, middleware.AuthToken，casbinMiddleware.ServeHTTP) //登录验证 admin.Get(\"/logout\", controllers.UserLogout).Name = \"退出\" }) } } } 这里中间件有一个新的 casbinmodel.conf文件，需要把里面的内容替换到前面提到的 rbac_model.conf 文件中。 现在登陆项目访问任何接口都会出现 403 拒绝访问的状态返回，这说明中间件生效了。接下来我们需要使用 casbin 提供的 Api 将项目的用户，角色和权限相互关联起来。 打开 rbac-api 页面，我们看到有一个 AddRoleForUser() 给用户添加","date":"2021-03-06  17:10:32","objectID":"/iris-go-api-2/:0:1","tags":["Golang","IRIS","Api"],"title":"iris + casbin 从陌生到学会使用的过程","uri":"/iris-go-api-2/"},{"categories":["Golang","IRIS"],"content":"后记 这里记录一下如何使用 iris 自动生成权限（策略）的思路。 首先，肯定要从路由入手，给路由都加上名称，方便区分权限。 app.PartyFunc(\"/users\", func(users iris.Party) { users.Get(\"/\", controllers.GetAllUsers).Name = \"用户列表\" users.Get(\"/{id:uint}\", controllers.GetUser).Name = \"用户详情\" users.Post(\"/\", controllers.CreateUser).Name = \"创建用户\" users.Put(\"/{id:uint}\", controllers.UpdateUser).Name = \"编辑用户\" users.Delete(\"/{id:uint}\", controllers.DeleteUser).Name = \"删除用户\" users.Get(\"/profile\", controllers.GetProfile).Name = \"个人信息\" }) 这样就可以在获取路由的时候获取到对应的名称了。 如何获取 iris 应用的路由信息？找了文档发现没有相关的方法。这时候我们只能取查看源码了。 在源码中我找到了如下源码： // GetRoutes 返回路由的信息, // 这些信息有些可以被修改，有些不可以。 // // 需要刷新路由器到方法或路径或处理程序更改才能进行。 func (api *APIBuilder) GetRoutes() []*Route { return api.routes.getAll() } // GetRoute 基于路由名称返回已注册路由， 否则返回nil。 // 一个提示： \"路由名称\" 区分大小写。 func (api *APIBuilder) GetRoute(routeName string) *Route { return api.routes.get(routeName) } // GetRouteByPath 基于模版路径 (`Route.Tmpl().Src`) 返回已注册路由。 func (api *APIBuilder) GetRouteByPath(tmplPath string) *Route { return api.routes.getByPath(tmplPath) } // GetRoutesReadOnly 返回只读授权的已注册路由， // 你不能也不应该在请求状态下改变路由的任何属性， // 如果想要改变可以使用 `GetRoutes()`函数替代。 // // 它返回基于接口的切片而不是实际切片， // 以便在上下文（请求状态）和构建的应用程序之间安全提取。 // // 同时请看 `GetRouteReadOnly` 。 func (api *APIBuilder) GetRoutesReadOnly() []context.RouteReadOnly { routes := api.GetRoutes() readOnlyRoutes := make([]context.RouteReadOnly, len(routes)) for i, r := range routes { readOnlyRoutes[i] = routeReadOnlyWrapper{r} } return readOnlyRoutes } 从以上源码中可以看出， GetRouteReadOnly 和 GetRoutes() 都满足我们的使用需求。我们使用 GetRoutesReadOnly()实现。 app = NewApp() // 初始化app routes := app.GetRoutesReadOnly() // 保存数据到数据库，详细代码查看 https://github.com/snowlyg/IrisAdminApi ... 这里会有个小问题，就是数据没有问题，但是访问类似编辑，更新等后面带有 id 会变化的接口，会出现 403 返回。可是明明已经都有权限数据了，而且其他接口也能正常访问，为什么会这样？ 检查发现原因是：生成的（权限）策略数据是这样的 /v1/admin/users/{id:uint} 实际上 casbin 匹配的权限应该是这样的 /dataset1/*，具体内容查看 casbinpolicy.csv 这时候有两种解决思路： 修改自动生成权限的逻辑，将 {id:uint}，替换成 *。 修改 casbin 的匹配逻辑。 因为第一种比较简单，这里主要讨论第二种方式，既然要修改 casbin 的匹配逻辑。首先要了解它的原理，很不巧和很多刚接触 casbin 的朋友一样，我对这些也不是很了解。这时候我门只能通过查看文档，以及源码来更深入的了解它。 点开文档 matchers 我查找到 matachers 部分适用于定于匹配规则的，但是这里没有更深层的解释要如何定义。 继续查看文档 function，在这里我们能够到不同的匹配模式，甚至我们可以自定义匹配函数。而且我们发现其中有两种匹配方式可能会满足我们，keyMatch3，keyMatch4都能匹配 {} 类似的表达式 。 那么我们来尝试修改 examples/rbac_model.conf 这个文件的内容，将 keyMatch改为keyMatch3，重启项目之后访问编辑相关接口，发现问题已经解决。（发现使用 keyMatch4，同样有效） [matchers] m = g(r.sub, p.sub) \u0026\u0026 keyMatch3(r.obj, p.obj) \u0026\u0026 (r.act == p.act || p.act == \"*\") 还有另外一种方式：用来修改默认的匹配。 首先修改 examples/rbac_model.conf 这个文件：去除中间的 \u0026\u0026 keyMatch3(r.obj, p.obj) 让 casbin 使用默认的匹配规则（默认为 keyMatch）。 [matchers] m = g(r.sub, p.sub) \u0026\u0026 (r.act == p.act || p.act == \"*\") 然后在 models/base.go 文件增加代码： import ( defaultrolemanager \"github.com/casbin/casbin/v2/rbac/default-role-manager\" \"github.com/casbin/casbin/v2/util\" ) ...... Enforcer, _ = casbin.NewEnforcer(\"examples/rbac_model.conf\", a) // 修改默认匹配为 KeyMatch3 rm := defaultrolemanager.NewRoleManager(10).(*defaultrolemanager.RoleManager) rm.AddMatchingFunc(\"KeyMatch3\", util.KeyMatch3) Enforcer.LoadPolicy() ...... 此方法和上面直接修改 examples/rbac_model.conf 文件的方式更复杂一些，这里只是介绍一下提供另一种思路。 写完了，感觉有点乱。主要还是讲述我解决需求和问题的一个思路。希望对你有帮助。 还是那句话：能力有限，不喜勿喷。 ","date":"2021-03-06  17:10:32","objectID":"/iris-go-api-2/:0:2","tags":["Golang","IRIS","Api"],"title":"iris + casbin 从陌生到学会使用的过程","uri":"/iris-go-api-2/"},{"categories":["Golang","PHP"],"content":"自己整理的一些PHP转GO新手问题，以及一些解决问题的经验分享","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","PHP"],"content":" 本文就是个人的一点学习经验，如果有表述错误的地方欢迎指正。 越来越多的朋友从 php 语言转入到 go 语言的学习中来。那么新手转 go 会遇到很多问题和瓶颈。 这个主要是很多朋友，并不知道从何入手学习这门新语言。而且大部分都会带着以前 php 的一些思维来学习。 我总结了一些常见的问题，并结合我自己的开源项目 IrisAdminApi 对这些问题做一些阐述， 希望能对 go 的初学者们能有一些帮助。 GO 语言 和 PHP有什么区别？ 如何启动一个 GO 程序？ 为什么开发的时候要用热编译工具？什么是热编译工具？ 为什么热编译工具安装后，还是会提示 command not found? 启动程序为什么会提示方法或者变量不存在？但是使用热编译工具又可以正常运行？ 如何使用 ide , 比如 Goland 开发 GO 程序？ 如何部署一个 GO 项目？ ","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/:0:0","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","PHP"],"content":"GO 语言 和 PHP 有什么区别？ PHP 脚本的生命周期及fpm(FastCGI进程管理器)的运作方式， 从下图可以看出 php 是动态语言，每一请求都会执行一次 php 脚本。 如下图： 然而 go 语言则完全不同，它是静态语言每次修改go脚本后，都必须重新编译才能生效。 go 语言通常有两个命令可以编译脚本，go run main.go , go build main.go。 go build main.go： 会在当前目录生成一个 main 可执行文件，windows 系统会生成 main.exe 可执行文件。 go run main.go ： 编译脚本的同时还会执行脚本，不会生成可执行文件。 注意：每次修改脚本后都需要重新编译脚本，不管你执行的是 go run main.go，还是 go build main.go 你的修改才会生效。 当然 go run main.go , go build main.go 还有其他的区别，有兴趣的朋友可以自行百度。 ","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/:0:1","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","PHP"],"content":"如何启动一个 GO 程序？ 可以通过 go run main.go 启动一个 go 程序。 也可以直接在命令行执行 ./main ,windows 系统双击 main.exe。 开发的时候通常会使用热编译工具：air , gowatch等等。 ","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/:0:2","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","PHP"],"content":"为什么开发的时候要用热编译工具？什么是热编译工具？ 热编译工具可以在你开发 go 脚本程序的时候，在你修改代码后，自动帮你执行编译命令，并执行编译好的执行文件。 热编译工具的原理很简单，就是启动一个协程实时的监控你的的项目文件。当监控到项目文件被修改后，执行相关命令。 为什么热编译工具安装后，还是会提示 command not found? 这个问题很简单，其实就是执行的命令不存在，或者存在但是系统找不到。 不管是什么系统都会有一套查找可执行命令的机制。通常都是通过设置系统变量来实现。 具体如何设置各系统的系统环境变量，这里不做介绍。 这里简单介绍一下如何排查自己安装的 go 工具,比如 gowatch,air 等命令执行的时候出现 command not found 的问题。 首先：查看一下 gopath/bin 目录下是否已经有对应的可执行文件，比如 air ，win 系统下是 air.exe 文件。如果没有说明没有安装成功，需要重新安装。 第二种情况：如果文件已经存在 gopath/bin 目录，还是出现 command not found 情况。那么说明你的 gopath/bin 目录，没有加入到系统环境变量。这时候有两种解决方法，第一种：直接复制执行文件到 goroot/bin 目录下。第二种：当然就是把 gopath/bin 目录加入系统环境变量了。 极少数情况：修改系统变量未生效，比如 windows 系统下未重启系统，linux 系统下未重启终端都有可能导致设置的系统变量不能生效。 启动程序为什么会提示方法或者变量不存在？但是使用热编译工具又可以正常运行？ 很多文档的介绍里面都是通过 go run main.go 启动 go 脚本程序。因为大部分的文档 go 脚本实例程序都只有一个文件 main.go 。 当你遇到一些文件比较多的项目的时候，比如IrisAdminApi 你会发现使用 go run main.go 会提示报错某些方法不存在。但是使用 air 热编译工具又可以正常启动程序。 这个原因是在 package main 这个包名下，其实有两个文件 main.go ，bindata.go。所以你需要执行 go run main.go bindata.go 才可以正常启动程序。你一定发现了原理 go run 后面是可以加多个文件的。 ","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/:0:3","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","PHP"],"content":"如何使用 ide , 比如 Goland 开发 GO 程序？ 使用 goland 开发主要会遇到一个坑：它里面的每个项目的 go 环境是隔离的，并不会共用 go env 里面的设置。 所以新建一个项目的时候都需要设置一次 go 环境的一些参数。 主要是GOROOT,GOPATH,Go Modules。这几个参数 Go Modules 是用于设置依赖代理。 ","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/:0:4","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","PHP"],"content":"如何部署一个 GO 项目？ 如何将一个 go 项目部署到服务器? 以 IrisAdminApi 项目举例： 直接启动编译文件，通过 Supervisor , pm2 等进程守护工具辅助部署，这种方式不方便升级维护，而且部署也相对复杂。（不推荐） 通过 docker 方式部署，将程序打包成 docker 镜像。然后通过 docker 启动程序，这种方式方便升级维护，适合经常需要版本迭代的程序。 直接执行编译生成的文件 ","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/:0:5","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","PHP"],"content":"go get …添加私有仓库依赖时,报错 (go 1.13+ 版本) 设置 GOPRIVATE 变量 export GOPRIVATE=gitlab.com/xxx ","date":"2021-03-06  16:56:40","objectID":"/learning-glang-for-phper/:0:6","tags":["Golang","PHP","new"],"title":"PHP 转 GO 新手问题汇总","uri":"/learning-glang-for-phper/"},{"categories":["Golang","IRIS"],"content":"简单的介绍iris-go框架构建登陆api后台项目的过程","date":"2021-03-06  16:33:37","objectID":"/iris-go-api-1/","tags":["Golang","IRIS","Api"],"title":"iris-go框架构建登陆api项目开发详解","uri":"/iris-go-api-1/"},{"categories":["Golang","IRIS"],"content":"具体项目实例 https://github.com/snowlyg/IrisAdminApi 相关文章： iris + casbin 从陌生到学会使用的过程 很多新手学习 iris-go 的时候，看文档会觉得有些零散。而且英文文档对有些小伙伴来说还是有些吃力，就算用上翻译软件有些地方也会翻译的生涩难以理解。这篇文章主要会详细的讲解一下，我在写一个小项目的实现过程。本人功力有限，如果有错误地方，希望大家友善的指出。 前言 首先需要安装 golang 环境 。具体安装教程可以查看 Go 入门指南 本地安装 mysql 或者 gcc (sqlite3) 环境 。gcc 下载地址 建议下载解压版本，安装版本下载会比较慢。 开启 GO111MODULE 模式，设置镜像 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn,direct 初始化 go.mod 文件 go mod init 安装 gowatch ，类似 bee run 的一个工具。 go get github.com/silenceper/gowatch 注意：如果是使用 goland Ide , 需要在 goland 的设置中为每一个项目单独开启 go moudels , 并且设置镜像地址，如下图。 新建项目 在 go/src/ (GOPATH) 目录下新建文件夹 IrisAdminApi ，并新建 main.go 文件。官方文档例子 https://iris-go.com/start/#installation。 package main import ( \"github.com/kataras/iris/v12\" \"github.com/kataras/iris/v12/middleware/logger\" \"github.com/kataras/iris/v12/middleware/recover\" ) func main(){ app := iris.New() app.Logger().SetLevel(\"debug\") //可选的, 增加两个内置的处理程序 // 一个可以让程序从任意的 http-relative panics 中恢复过来， // 一个可以记录日志到终端。 app.Use(recover.New()) app.Use(logger.New()) // Method: GET // Resource: http://localhost:8080 app.Handle(\"GET\", \"/\", func(ctx iris.Context) { ctx.HTML(\"\u003ch1\u003eWelcome\u003c/h1\u003e\") }) // same as app.Handle(\"GET\", \"/ping\", [...]) // Method: GET // Resource: http://localhost:8080/ping app.Get(\"/ping\", func(ctx iris.Context) { ctx.WriteString(\"pong\") }) // Method: GET // Resource: http://localhost:8080/hello app.Get(\"/hello\", func(ctx iris.Context) { ctx.JSON(iris.Map{\"message\": \"Hello Iris!\"}) }) // http://localhost:8080 // http://localhost:8080/ping // http://localhost:8080/hello app.Run(iris.Addr(\":8080\"), iris.WithoutServerError(iris.ErrServerClosed)) } 加载相关包 go mod tidy,此时 go.mod 和 go.sum 会加载包的相关信息。 // go.mod module IrisAdmin go 1.13 require ( github.com/CloudyKit/fastprinter v0.0.0-20200109182630-33d98a066a53 // indirect github.com/ajg/form v1.5.1 // indirect github.com/fasthttp-contrib/websocket v0.0.0-20160511215533-1f3b11f56072 // indirect github.com/google/go-querystring v1.0.0 // indirect github.com/imkira/go-interpol v1.1.0 // indirect github.com/k0kubun/colorstring v0.0.0-20150214042306-9440f1994b88 // indirect github.com/kataras/iris/v12 v12.1.4 github.com/mattn/go-colorable v0.1.4 // indirect github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect github.com/modern-go/reflect2 v1.0.1 // indirect github.com/moul/http2curl v1.0.0 // indirect github.com/onsi/ginkgo v1.11.0 // indirect github.com/onsi/gomega v1.8.1 // indirect github.com/sergi/go-diff v1.1.0 // indirect github.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect github.com/smartystreets/goconvey v1.6.4 // indirect github.com/valyala/fasthttp v1.8.0 // indirect github.com/xeipuuv/gojsonschema v1.2.0 // indirect github.com/yalp/jsonpath v0.0.0-20180802001716-5cc68e5049a0 // indirect github.com/yudai/gojsondiff v1.0.0 // indirect github.com/yudai/golcs v0.0.0-20170316035057-ecda9a501e82 // indirect github.com/yudai/pp v2.0.1+incompatible // indirect ) 启动项目 ，在项目目录运行 gowatch 或者 go run main.go。 输入 http://localhost:8080 ，得到如下显示就表启动成功了。 实现登陆，退出功能 到现在我们只是实现了一个简单的 web 服务器，和几个简单的接口。接下来我们要来实现网站的基本功能登陆和退出。 这里我们使用单元测试驱动开发相关接口，这样做的我们的项目后期的维护会变得相对容易一些。 首先要修改我们的 main.go 文件，新建一个 NewApp 方法，这个方法返回-个 *iris.Application ，这个是 iris.Application 的一个指针。（具体为什么是指针，这里就不详细讲解了。可以去看下 [Go 入门指南]https://learnku.com/docs/the-way-to-go ），这个方法在单元测试会用到。 package main import ( \"github.com/kataras/iris/v12\" \"github.com/kataras/iris/v12/middleware/logger\" \"github.com/kataras/iris/v12/middleware/recover\" ) func main(){ app := NewApp() // http://localhost:8080 // http://localhost:8080/ping // http://localhost:8080/hello app.Run(iris.Addr(\":8080\"), iris.WithoutServerError(iris.ErrServerClosed)) } func NewApp() *iris.Application { app := iris.New() app.Logger().SetLevel(\"debug\") // Optionally, add two built'n handlers // that can recover from any http-relative panics // and log the requests to the terminal. app.Use(recover.New()) app.Use(logger.New()) // Method: GET // Resource: http://localhost:8080 app.Handle(\"GET\", \"/\", func(ctx ","date":"2021-03-06  16:33:37","objectID":"/iris-go-api-1/:0:0","tags":["Golang","IRIS","Api"],"title":"iris-go框架构建登陆api项目开发详解","uri":"/iris-go-api-1/"},{"categories":["Golang"],"content":"Golang 支持交叉编译，在一个平台上生成另一个平台的可执行程序，最近使用了一下，非常好用，这里备忘一下。","date":"2021-03-06  13:55:40","objectID":"/golang-for-build/","tags":["Golang","build","cross-platform"],"title":"Golang 如何交叉编译？在一个平台上生成另一个平台的可执行程序","uri":"/golang-for-build/"},{"categories":["Golang"],"content":"介绍 Golang 支持交叉编译，在一个平台上生成另一个平台的可执行程序，最近使用了一下，非常好用，这里备忘一下。 https://blog.csdn.net/hbzhou2009/article/details/77677160 CGO_ENABLED 是否启用 CGO CGO_ENABLED=1 Mac 下编译 Linux 和 Windows 64位可执行程序 如果启用了 cgo 需要安装 gcc , 如果是跨平台编译还需要通过 CC 参数指定所需平台的 gcc 组件 如下命令所示： CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go mac to windows CGO_ENABLED=1 GOOS=windows GOARCH=amd64 CC=/usr/local/bin/x86_64-w64-mingw32-gcc CXX=/usr/local/bin/x86_64-w64-mingw32-g+ go build -a -installsuffix cgo -ldflags \"-w -s -X main.Version=v1.0\" -o ./cmd/main.exe mac to linux CGO_ENABLED=1 GOOS=linux GOARCH=amd64 CC=/usr/local/gcc-4.8.1-for-linux64/bin/x86_64-pc-linux-gcc go build -a -installsuffix cgo -ldflags \"-w -s -X main.Version=v1.0\" -o ./cmd/main_lin Linux 下编译 Mac 和 Windows 64位可执行程序 CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build main.go CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build main.go Windows 下编译 Mac 和 Linux 64位可执行程序 SET CGO_ENABLED=0 SET GOOS=darwin SET GOARCH=amd64 go build main.go SET CGO_ENABLED=0 SET GOOS=linux SET GOARCH=amd64 go build main.go GOOS：目标平台的操作系统（darwin、freebsd、linux、windows） GOARCH：目标平台的体系架构（386、amd64、arm） ","date":"2021-03-06  13:55:40","objectID":"/golang-for-build/:0:0","tags":["Golang","build","cross-platform"],"title":"Golang 如何交叉编译？在一个平台上生成另一个平台的可执行程序","uri":"/golang-for-build/"}]